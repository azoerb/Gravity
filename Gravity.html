<!DOCTYPE HTML>
<html>
<head>
<title>Test</title>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
        precision highp float;
    #endif

    varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vColor;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
    }
</script>

<script id="texture-shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
        precision highp float;
    #endif

    varying vec2 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 color = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4 (color.r * color.a, color.g * color.a, color.b * color.a, color.a);
    }
</script>

<script id="texture-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

<script type="text/javascript" src="Vector.js"></script>

<script type="text/javascript" src="GameObject.js"></script>

<script type="text/javascript">
    
    var MOUSE_SENSITIVITY = 1.3; // Higher = more sensitive
    var MOUSE_EXPONENT = 1.3; // Higher = quicker ramp up
    
    var canvas;
    
//OPEN GL VARS
    var gl;
    var shaderProgram;
    var textureShaderProgram;
    
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();
        
    var INTERVAL = 60;
    var timeDelta;
    var currentTime;
    var oldTime;
    var fps;
        
    var keyDown = new Array();
    var mousePos = new Vector(0.0, 0.0, 0.0);
    
    var playerPos = new Vector(0.0, 0.0, 0.0);
    var playerRotation = new Vector(0.0, 0.0, 0.0);
    
    var cube;
    var crosshair;
  
    function init() {
        canvas = document.getElementById("Canvas");
    
        document.onkeyup = handleKeyUp;
        document.onkeydown = handleKeyDown;
        document.onclick = handleMouseClick;
        document.onmousemove = handleMouseMove;
                
        webGLStart(canvas);

        setInterval(function() {
                    update();
                    drawScene();
                    }, 1000 / INTERVAL);
    }
    
    function webGLStart(canvas) {
        initGL(canvas);
        createObjects();
        initShaders();
        initBuffers();
        
        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        
        //// Disable CullFace for now so that cube renders on both sides
        gl.disable(gl.CULL_FACE);
        ////
        
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    }

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
            alert("Could not initialise WebGL");
        }
        if (!gl) {
            alert("Could not initialise WebGL");
        }
    }
    
    function createObjects() {
        cube = new GameObject("Cube", [0.0, 0.0, 0.0], 60.0, [0.0, -1.0, 0.0], [0.0, 0.0, 0.0], false, false, null);
        crosshair = new GameObject("Crosshair", 0, 0, 0, 0, true, true, "Crosshair.png");
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function initShaders() {
        // Cube color shaders
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");
        
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
                
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        
        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
        
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        
        // Texture Shaders
        var textureFragmentShader = getShader(gl, "texture-shader-fs");
        var textureVertexShader = getShader(gl, "texture-shader-vs");
        
        textureShaderProgram = gl.createProgram();
        gl.attachShader(textureShaderProgram, textureVertexShader);
        gl.attachShader(textureShaderProgram, textureFragmentShader);
        gl.linkProgram(textureShaderProgram);
        
        if (!gl.getProgramParameter(textureShaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        
        textureShaderProgram.vertexPositionAttribute = gl.getAttribLocation(textureShaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(textureShaderProgram.vertexPositionAttribute);
        
        textureShaderProgram.textureCoordAttribute = gl.getAttribLocation(textureShaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(textureShaderProgram.textureCoordAttribute);
        
        textureShaderProgram.pMatrixUniform = gl.getUniformLocation(textureShaderProgram, "uPMatrix");
        textureShaderProgram.mvMatrixUniform = gl.getUniformLocation(textureShaderProgram, "uMVMatrix");
        textureShaderProgram.samplerUniform = gl.getUniformLocation(textureShaderProgram, "uSampler");
    }

    function initBuffers() {
    // Crosshair Buffers
        crosshair.vertices = [-1.0, -1.0,  0.0,
                              1.0, -1.0,  0.0,
                              1.0,  1.0,  0.0,
                             -1.0,  1.0,  0.0];
                             
        crosshair.textCoords = [0.0, 0.0,
                                1.0, 0.0,
                                1.0, 1.0,
                                0.0, 1.0];
                                
        crosshair.indices = [0, 1, 2, 0, 2, 3];
        
        crosshair.initObject();
        
    // Cube Buffers
        cube.vertices = [-1.0, -1.0,  1.0, // Front face
                          1.0, -1.0,  1.0,
                          1.0,  1.0,  1.0,
                         -1.0,  1.0,  1.0,
                     
                         -1.0, -1.0, -1.0, // Back face
                         -1.0,  1.0, -1.0,
                          1.0,  1.0, -1.0,
                          1.0, -1.0, -1.0,
                     
                         -1.0,  1.0, -1.0, // Top face
                         -1.0,  1.0,  1.0,
                          1.0,  1.0,  1.0,
                          1.0,  1.0, -1.0,
                     
                         -1.0, -1.0, -1.0, // Bottom face
                          1.0, -1.0, -1.0,
                          1.0, -1.0,  1.0,
                         -1.0, -1.0,  1.0,
                     
                          1.0, -1.0, -1.0, // Right face
                          1.0,  1.0, -1.0,
                          1.0,  1.0,  1.0,
                          1.0, -1.0,  1.0,
                     
                         -1.0, -1.0, -1.0, // Left face
                         -1.0, -1.0,  1.0,
                         -1.0,  1.0,  1.0,
                         -1.0,  1.0, -1.0 ];
                     
        cube.colors = [[1.0, 0.0, 0.0, 1.0], // Front face
                       [1.0, 1.0, 0.0, 1.0], // Back face
                       [0.0, 1.0, 0.0, 1.0], // Top face
                       [1.0, 0.5, 0.5, 1.0], // Bottom face
                       [1.0, 0.0, 1.0, 1.0], // Right face
                       [0.0, 0.0, 1.0, 1.0]];  // Left face
                   
        cube.indices = [0, 1, 2,      0, 2, 3,    // Front face
                        4, 5, 6,      4, 6, 7,    // Back face
                        8, 9, 10,     8, 10, 11,  // Top face
                        12, 13, 14,   12, 14, 15, // Bottom face
                        16, 17, 18,   16, 18, 19, // Right face
                        20, 21, 22,   20, 22, 23];  // Left face
        
        cube.initObject();
    }
    
    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms(program) {
        gl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }
           
    function checkKeys() {
        if (keyDown[39]) { // Right
        }
        
        if (keyDown[37]) { // Left
        }
        
        if (keyDown[38]) { // Up
        }
        
        if (keyDown[40]) { // Down
        }
    }
    
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
        mat4.identity(mvMatrix);
        
        // Draw Cube
        gl.useProgram(shaderProgram);
        mvPushMatrix();
        
        // Apply player rotation
        mat4.rotate(mvMatrix, degToRad(playerRotation.y), [1.0, 0.0, 0.0]);
        mat4.rotate(mvMatrix, degToRad(playerRotation.x), [0.0, 1.0, 0.0]);
        mat4.rotate(mvMatrix, degToRad(playerRotation.z), [0.0, 0.0, 1.0]);

        cube.draw(shaderProgram);
        mvPopMatrix();
        
        // Draw Crosshair
        gl.useProgram(textureShaderProgram);
        mvPushMatrix();
        mat4.translate(mvMatrix, [0.0, 0.0, -25.0]);
        
        crosshair.draw(textureShaderProgram);
        mvPopMatrix();
    }

    function update() {
    	oldTime = currentTime;
        currentTime = new Date();
        timeDelta = currentTime - oldTime;
        fps = 1000 / timeDelta;
        
        // We have to save the sign of the mouse position since we can't raise a negative number
        // to a partial exponent.  We re-multiply the result by the sign afterwards.
        var xSign;
        if (mousePos.x >= 0) {
            xSign = 1;
        } else {
            xSign = -1;
        }
        
        playerRotation.x += xSign * Math.pow(Math.abs(mousePos.x) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        playerRotation.x %= 360;
      
          
        var ySign;
        if (mousePos.y >= 0) {
            ySign = 1;
        } else {
            ySign = -1;
        }
        
        playerRotation.y += ySign * Math.pow(Math.abs(mousePos.y) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        
        if (playerRotation.y >= 90) {
            playerRotation.y = 90;
        } else if (playerRotation.y <= -90) {
            playerRotation.y = -90;
        }
                
        if (keyDown[38]) {
            
        }
    }
    
    function handleKeyDown(evt) {
        keyDown[evt.keyCode] = true;
    }
 
    function handleKeyUp(evt) {
        keyDown[evt.keyCode] = false;
    }
        
    function handleMouseMove(evt) {
    if (navigator.userAgent.indexOf("Firefox")!=-1) {
        mousePos.x = evt.clientX - canvas.offsetLeft - canvas.width / 2;
        mousePos.y = evt.clientY - canvas.offsetTop - canvas.height / 2;
    } else {
        mousePos.x = evt.x - canvas.offsetLeft - canvas.width / 2;
        mousePos.y = evt.y - canvas.offsetTop - canvas.height / 2;
    }
	}
    
    function handleMouseClick(evt) {
    
	}
    
    function debug(text) {
        document.getElementById('debug').innerHTML = text;
    }
    
</script>
</head>

<body onload="init()" style="text-align:center">
    <canvas id="Canvas" width="800" height="600" style="border:1px solid #eeeeee ">
        Your browser does not support the canvas element.
    </canvas>
    <div id="debug"></div>
</body>
</html>