<!DOCTYPE HTML>
<html>
<head>
<title>Gravity</title>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
        precision highp float;
    #endif

    varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vColor;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
    }
</script>

<script id="texture-shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
        precision highp float;
    #endif

    varying vec2 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 color = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4 (color.r*color.a , color.g*color.a , color.b*color.a , color.a);
    }
</script>

<script id="texture-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
	}
	</script>
<script id="glow-texture-shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
        precision highp float;
    #endif

    varying vec2 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 color = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4 (color.r*3.0 , color.g*3.0 , color.b*3.0 , color.a);
    }
</script>

<script id="glow-texture-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
	}
	</script>
	
<script id="light-shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
        precision highp float;
    #endif

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
	varying vec4 vPosition;
	
	uniform mat4 uMVMatrix;	
    
	uniform vec3 uAmbientColor;
    
    uniform float uMaterialShininess;
    
    uniform vec3 uLightingLocation;
	uniform vec3 uLightingSpecularColor;
    uniform vec3 uLightingDiffuseColor;

    uniform sampler2D uSampler;

    void main(void) {
		vec3 transformedDir = vec3(uMVMatrix * vec4(uLightingLocation, 0.0));
        vec3 lightDirection = normalize(transformedDir - vPosition.xyz);
        vec3 normal = normalize(vTransformedNormal);
      
        vec3 eyeDirection = normalize(-vPosition.xyz);
        vec3 reflectionDirection = reflect(-lightDirection, normal);

        float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);

        float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
        vec3 lightWeighting = uAmbientColor + uLightingDiffuseColor * diffuseLightWeighting;

        vec4 fragmentColor;
        fragmentColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4((fragmentColor.rgb * lightWeighting) + uLightingSpecularColor * specularLightWeighting , fragmentColor.a);
    }
</script>

<script id="light-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

	varying vec2 vTextureCoord;
	varying vec3 vTransformedNormal;
	varying vec4 vPosition;

    void main(void) {
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		vTextureCoord = aTextureCoord;
		vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>

<script type="text/javascript" src="jquery-1.6.4.js"></script>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

<script type="text/javascript" src="objects/DrawableObject.js"></script>

<script type="text/javascript" src="objects/HUDObject.js"></script>

<script type="text/javascript" src="objects/GameObject.js"></script>

<script type="text/javascript" src="objects/BeamObject.js"></script>

<script type="text/javascript" src="objects/LevelObject.js"></script>


<script type="text/javascript">
    
    var MOUSE_SENSITIVITY = 0.7; // Higher = more sensitive
    var MOUSE_EXPONENT = 1.4; // Higher = quicker ramp up
    var MOVEMENT_SPEED = -0.07;
    var COLLISION_DISTANCE = .1;
    
    var canvas;
    
//OPEN GL VARS
    var gl;
    var shaderProgram;
    var lightShaderProgram;
    var textureShaderProgram;
    var glowTextureShaderProgram;
    
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();
        
    var INTERVAL = 60;
    var timeDelta;
    var currentTime;
    var oldTime;
    var fps;
    var firstTimeThrough;
        
    var keyDown = new Array();
    var mousePos = vec3.create();
    
    var player;

    var cube;
    var crosshair;
	var test;

	var door;
	var sensor;
	var sensor2;
	var drawDoor=false;
	var doorOpened=false;
	var doorCollide=false;
    var lvlTop;
    var lvlBot;
    var lvlRt;
    var lvlLt;
    var lvlBack;
    var lvlFrnt;
   	var lvlTop2;
    var lvlBot2;
    var lvlRt2;
    var lvlLt2;
    var lvlBack2;
    var lvlFrnt2;
    var lvlTop3;
    var lvlBot3;
    
    var level=1;
    var levelSetUp=false;
	
    var walls;
    var fallables;
    var moveables;
    
    var ambientLight = [0.2, 0.2, 0.2];
	var lightPos = [1.0, 3.0, 0.0];
	var lightDiffColor = [0.7, 0.7, 0.7];
	var lightSpecColor = [0.4, 0.4, 0.4];
    
    var rayLen = 10;
	var rayIter = 0.001;
	var rayTracing = false;
	var rayTracing2 = false;
	var spacePressed = false;
	
	var rayObjects = [];
    
	var showMenu = false;
  
    function init() {
        canvas = document.getElementById("Canvas");
    
        document.onkeyup = handleKeyUp;
        document.onkeydown = handleKeyDown;
        document.onmousedown = handleMouseDown;
		document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;
		document.onclick = handleMouseClick;
                
        webGLStart(canvas);
        
        firstTimeThrough = true;

        setInterval(function() {
                    update();
                    drawScene();
                    }, 1000 / INTERVAL);
    }
    
    function webGLStart(canvas) {
        initGL(canvas);
        createObjects();
        initShaders();
        initBuffers();
		setBallList(20);
        
        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.enable(gl.TEXTURE_2D);
        
        //// Disable CullFace for now so that cube renders on both sides
        gl.disable(gl.CULL_FACE);
        ////
        
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    }

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
            alert("Could not initialise WebGL");
        }
        if (!gl) {
            alert("Could not initialise WebGL");
        }
    }
    
    function createObjects() {
        player = new GameObject([0.2, 0.0, 0.2], 60.0, [0, -1, 0], [0.0, 0.0, 0.0], false, null);
        
        player.dimensions[0] = .1;
        player.dimensions[1] = .1;
        player.dimensions[2] = .1;
        
        //cube = new GameObject([0.0, 0.0, 0.0], 60.0, [0, -1, 0], [0.0, 0.0, 0.0], true, false, "textures/checker1-pCube1.1.jpg");
        //cube.loadModel("models/Level1.obj");
        lvlTop = new LevelObject(true,false,"up","textures/CubeTop.png");
        lvlTop.loadModel("models/lvlTop.obj");
		//rayObjects[rayObjects.length] = lvlTop;
        
        lvlBot = new LevelObject(true,false,"down","textures/CubeBot.png");
        lvlBot.loadModel("models/lvlBot.obj");
		//rayObjects[rayObjects.length] = lvlBot;
		
		lvlBot2 = new LevelObject(true,false,"down","textures/CubeBot.png");
        lvlBot2.loadModel("models/lvlBot2.obj");
		//rayObjects[rayObjects.length] = lvlBot2;
		
		lvlBot3 = new LevelObject(true,false,"down","textures/CubeBot.png");
        lvlBot3.loadModel("models/lvlBot3.obj");
		//rayObjects[rayObjects.length] = lvlBot3;
		
		lvlBot = new LevelObject(true,false,"down","textures/CubeBot.png");
        lvlBot.loadModel("models/lvlBot.obj");
		//rayObjects[rayObjects.length] = lvlBot;
        
        lvlLt = new LevelObject(true,false,"left","textures/CubeLt.png");
        lvlLt.loadModel("models/lvlLft.obj");
		//rayObjects[rayObjects.length] = lvlLt;
		
		lvlLt2 = new LevelObject(true,false,"left","textures/CubeLt.png");
        lvlLt2.loadModel("models/lvlLft2.obj");
		//rayObjects[rayObjects.length] = lvlLt2;
		
		lvlTop2 = new LevelObject(true,false,"up","textures/CubeTop.png");
        lvlTop2.loadModel("models/lvlTop2.obj");
		//rayObjects[rayObjects.length] = lvlTop2;
		
		lvlTop3 = new LevelObject(true,false,"up","textures/CubeTop.png");
        lvlTop3.loadModel("models/lvlTop3.obj");
		//rayObjects[rayObjects.length] = lvlTop3;
		
		
        
        lvlRt = new LevelObject(true,false,"right","textures/CubeRt.png");
        lvlRt.loadModel("models/lvlRt.obj");
		//rayObjects[rayObjects.length] = lvlRt;
		
         lvlRt2 = new LevelObject(true,false,"right","textures/CubeRt.png");
        lvlRt2.loadModel("models/lvlRt2.obj");
		//rayObjects[rayObjects.length] = lvlRt2;
		
        lvlFrnt = new LevelObject(true,false,"front","textures/CubeFrt.png");
        lvlFrnt.loadModel("models/lvlFrnt.obj");
		//rayObjects[rayObjects.length] = lvlFrnt;
		
		lvlFrnt2 = new LevelObject(true,false,"front","textures/CubeFrt.png");
        lvlFrnt2.loadModel("models/lvlFrnt2.obj");
		//rayObjects[rayObjects.length] = lvlFrnt2;
        
        lvlBack = new LevelObject(true,false,"back","textures/CubeBack.png");
        lvlBack.loadModel("models/lvlBack.obj");
		//rayObjects[rayObjects.length] = lvlBack;
		
		lvlBack2 = new LevelObject(true,false,"back","textures/CubeBack.png");
        lvlBack2.loadModel("models/lvlBack2.obj");
		//rayObjects[rayObjects.length] = lvlBack2;
		
		lvlBack3 = new LevelObject(true,false,"back","textures/CubeBack.png");
        lvlBack3.loadModel("models/lvlBack3.obj");
		//rayObjects[rayObjects.length] = lvlBack3;
        
        
        crosshair = new HUDObject("textures/Crosshair.png");
		title = new HUDObject("images/title.png");
		playButton = new HUDObject("images/menu_play.png");
		
        test = new GameObject([0.0, 0.0, 0.0], 60.0, [0, -1, 0], [0.0, 0.0, 0.0], true, "textures/ramp1-pCube1.jpg");
		test.loadModel("models/cube.obj");
		rayObjects[rayObjects.length] = test;
		
		beam = new GameObject([0.0, 0.0, 0.0], 60.0, [0.0, -1.0, 0.0], [0.0, 0.0, 0.0], true, "textures/beam.png");
		beam.loadModel("models/beam.obj");
		
		beam2 = new GameObject([0.0, 0.0, 0.0], 60.0, [0.0, -1.0, 0.0], [0.0, 0.0, 0.0], true, "textures/beam2.png");
		beam2.loadModel("models/beam.obj");
		
		sensor = new GameObject([0.0,1.85,0.0], 60.0, [0, -1,0], [0.0, 0.0, 0.0], true, "textures/ramp1-pCube2.jpg");
		sensor.loadModel("models/sensor.obj");
		
		sensor2 = new GameObject([1.8,-1.85,-6], 60.0, [0, -1,0], [0.0, 0.0, 0.0], true, "textures/ramp1-pCube2.jpg");
		sensor2.loadModel("models/sensor2.obj");
        
        sensor.dimensions[1] += .2;
		
		door = new GameObject([0, -1, 1.96], 60.0, [0, -1, 0], [0.0, 0.0, 0.0], true, "textures/ramp2-pPlane1.jpg");
		door.loadModel("models/door.obj");
        
        if(level==1){
        	walls=[lvlTop, lvlBot, lvlLt, lvlRt, lvlBack, lvlFrnt];
        	}
        else if(level==2){	
        	walls = [lvlTop, lvlBot, lvlTop2, lvlTop3, lvlBot2, lvlBot3, lvlRt, lvlRt2, lvlLt2, lvlFrnt, lvlFrnt2, lvlLt, lvlBack2, lvlBack3 /*, lvlLt, lvlBack, lvlFrnt*/];
        }
        for(i=0;i<walls.length;i++){
        	rayObjects[rayObjects.length]=walls[i];
        }
        moveables = [player, test];
        
        changeGravity();
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
			console.log("Shader not found");
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function initShaders() {
        // Cube color shaders
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");
        
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
                
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        
        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
        
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        
        // Texture Shaders
        var textureFragmentShader = getShader(gl, "texture-shader-fs");
        var textureVertexShader = getShader(gl, "texture-shader-vs");
        
        textureShaderProgram = gl.createProgram();
        gl.attachShader(textureShaderProgram, textureVertexShader);
        gl.attachShader(textureShaderProgram, textureFragmentShader);
        gl.linkProgram(textureShaderProgram);
        
        if (!gl.getProgramParameter(textureShaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        
        textureShaderProgram.vertexPositionAttribute = gl.getAttribLocation(textureShaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(textureShaderProgram.vertexPositionAttribute);
        
        textureShaderProgram.textureCoordAttribute = gl.getAttribLocation(textureShaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(textureShaderProgram.textureCoordAttribute);
        
        textureShaderProgram.pMatrixUniform = gl.getUniformLocation(textureShaderProgram, "uPMatrix");
        textureShaderProgram.mvMatrixUniform = gl.getUniformLocation(textureShaderProgram, "uMVMatrix");
        textureShaderProgram.samplerUniform = gl.getUniformLocation(textureShaderProgram, "uSampler");
        //Glow texture shader
        var glowTextureFragmentShader = getShader(gl, "glow-texture-shader-fs");
        var glowTextureVertexShader = getShader(gl, "glow-texture-shader-vs");
        
        glowTextureShaderProgram = gl.createProgram();
        gl.attachShader(glowTextureShaderProgram, glowTextureVertexShader);
        gl.attachShader(glowTextureShaderProgram, glowTextureFragmentShader);
        gl.linkProgram(glowTextureShaderProgram);
        
        if (!gl.getProgramParameter(glowTextureShaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        
        glowTextureShaderProgram.vertexPositionAttribute = gl.getAttribLocation(glowTextureShaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(glowTextureShaderProgram.vertexPositionAttribute);
        
        glowTextureShaderProgram.textureCoordAttribute = gl.getAttribLocation(glowTextureShaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(glowTextureShaderProgram.textureCoordAttribute);
        
        glowTextureShaderProgram.pMatrixUniform = gl.getUniformLocation(glowTextureShaderProgram, "uPMatrix");
        glowTextureShaderProgram.mvMatrixUniform = gl.getUniformLocation(glowTextureShaderProgram, "uMVMatrix");
        glowTextureShaderProgram.samplerUniform = gl.getUniformLocation(glowTextureShaderProgram, "uSampler");
		
        // Light Shaders
        var lightFragmentShader = getShader(gl, "light-shader-fs");
        var lightVertexShader = getShader(gl, "light-shader-vs");
        
        lightShaderProgram = gl.createProgram();
        gl.attachShader(lightShaderProgram, lightVertexShader);
        gl.attachShader(lightShaderProgram, lightFragmentShader);
        gl.linkProgram(lightShaderProgram);
        
        if (!gl.getProgramParameter(lightShaderProgram, gl.LINK_STATUS)) {
            console.log("Could not initialise shaders");
        }
        
		lightShaderProgram.vertexPositionAttribute = gl.getAttribLocation(lightShaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(lightShaderProgram.vertexPositionAttribute);

        lightShaderProgram.vertexNormalAttribute = gl.getAttribLocation(lightShaderProgram, "aVertexNormal");
		gl.enableVertexAttribArray(lightShaderProgram.vertexNormalAttribute);

        lightShaderProgram.textureCoordAttribute = gl.getAttribLocation(lightShaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(lightShaderProgram.textureCoordAttribute);
		
        lightShaderProgram.pMatrixUniform = gl.getUniformLocation(lightShaderProgram, "uPMatrix");
        lightShaderProgram.mvMatrixUniform = gl.getUniformLocation(lightShaderProgram, "uMVMatrix");
		lightShaderProgram.nMatrixUniform = gl.getUniformLocation(lightShaderProgram, "uNMatrix");
        lightShaderProgram.samplerUniform = gl.getUniformLocation(lightShaderProgram, "uSampler");
		lightShaderProgram.materialShininessUniform = gl.getUniformLocation(lightShaderProgram, "uMaterialShininess");
		lightShaderProgram.ambientColorUniform = gl.getUniformLocation(lightShaderProgram, "uAmbientColor");
        lightShaderProgram.lightingLocationUniform = gl.getUniformLocation(lightShaderProgram, "uLightingLocation");
        lightShaderProgram.lightingDiffuseColorUniform = gl.getUniformLocation(lightShaderProgram, "uLightingDiffuseColor");
		lightShaderProgram.lightingSpecularColorUniform = gl.getUniformLocation(lightShaderProgram, "uLightingSpecularColor");
    }

    function initBuffers() {
    // Crosshair Buffers
        crosshair.vertices = [-1.0, -1.0,  0.0,
                              1.0, -1.0,  0.0,
                              1.0,  1.0,  0.0,
                             -1.0,  1.0,  0.0];
                             
        crosshair.textCoords = [0.0, 0.0,
                                1.0, 0.0,
                                1.0, 1.0,
                                0.0, 1.0];
                                
        crosshair.indices = [0, 1, 2, 0, 2, 3];
        
        crosshair.initObject();
		
		title.vertices = [-4.0, -3.0,  0.0,
                          4.0, -3.0,  0.0,
                          4.0,  3.0,  0.0,
                         -4.0,  3.0,  0.0];
                             
        title.textCoords = [0.0, 0.0,
                            1.0, 0.0,
                            1.0, 1.0,
                            0.0, 1.0];
                                
        title.indices = [0, 1, 2, 0, 2, 3];
        
        title.initObject();
		
		playButton.vertices = [-2.0, -1.0,  0.0,
				  2.0, -1.0,  0.0,
				  2.0,  1.0,  0.0,
				 -2.0,  1.0,  0.0];
                             
        playButton.textCoords = [0.0, 0.0,
                            1.0, 0.0,
                            1.0, 1.0,
                            0.0, 1.0];
                                
        playButton.indices = [0, 1, 2, 0, 2, 3];
        
        playButton.initObject();
        
       // cube.initObject();
       for(i=0;i<walls.length;i++){
       		walls[i].initObject();
       		}
       	/*lvlTop.initObject();
       	lvlBot.initObject();
       	lvlRt.initObject();
       	lvlLt.initObject();
       	lvlFrnt.initObject();
       	lvlBack.initObject();
		*/
		test.initObject();
		beam.initObject();
		beam2.initObject();
		sensor.initObject();
		sensor2.initObject();
		door.initObject();
    }
    
    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms(program) {
        gl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);
		
		var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(program.nMatrixUniform, false, normalMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }
           
    function checkKeys() {
        var angle = player.invertY * player.rotationVector[player.localY];
        var down = false;
                
        if (keyDown[87]) { // W
            down = true;
            player.velocity[player.localX] = player.invertX * MOVEMENT_SPEED * Math.sin(degToRad(angle));
            player.velocity[player.localZ] = player.invertZ * MOVEMENT_SPEED * Math.cos(degToRad(angle));
        } else if (keyDown[83]) { // S
            down = true;
            player.velocity[player.localX] = -player.invertX * MOVEMENT_SPEED * Math.sin(degToRad(angle));
            player.velocity[player.localZ] = -player.invertZ * MOVEMENT_SPEED * Math.cos(degToRad(angle));
        }
        
        if (keyDown[65]) { // A
            down = true;
            player.velocity[player.localX] = player.invertX * MOVEMENT_SPEED * Math.sin(degToRad(-90.0 + angle));
            player.velocity[player.localZ] = player.invertZ * MOVEMENT_SPEED * Math.cos(degToRad(-90.0 + angle));
        } else if (keyDown[68]) { // D
            down = true;
            player.velocity[player.localX] = -player.invertX * MOVEMENT_SPEED * Math.sin(degToRad(-90.0 + angle));
            player.velocity[player.localZ] = -player.invertZ * MOVEMENT_SPEED * Math.cos(degToRad(-90.0 + angle));
        }
        
        if (!down) {
            player.velocity[player.localX] = 0;
            player.velocity[player.localZ] = 0;
        }
		if (keyDown[32]) { //space
			spacePressed = true;
		} else {
			spacePressed = false;
		}
        /*
        if (keyDown[37]) { // Left
            player.gravityVector = [-1, 0, 0];
            changeGravity();
        } else if (keyDown[38]) { // Up
            player.gravityVector = [0, 1, 0];
            changeGravity();
        } else if (keyDown[39]) { // Right
            player.gravityVector = [1, 0, 0];
            changeGravity();
        } else if (keyDown[40]) { // Down
            player.gravityVector = [0, -1, 0];
            changeGravity();
        } else if (keyDown[70]) { // F (Front)
            player.gravityVector = [0, 0, -1];
            changeGravity();
        } else if (keyDown[66]) { // B (Back)
            player.gravityVector = [0, 0, 1];
            changeGravity();
        } else if (keyDown[82]) { // R (Reset)
            player.globalPosition = [0, 0, 0];
            player.gravityVector = [0, -1, 0];
        }
		*/
        
        if (keyDown[82]) { // R (Reset)
            player.globalPosition = [.2, 0, .2];
            player.gravityVector = [0, -1, 0];
            player.velocity = [0, 0, 0];
            player.fall = true;
            
            test.globalPosition = [0, 0, 0];
            test.gravityVector = [0, -1, 0];
            test.velocity = [0, 0, 0];
            test.fall = true;
        }
    }
    
    function changeGravity() {
        gravToGlobal(player);
		gravToGlobal(door);
		gravToGlobal(sensor);
        player.fall = true;
        if (!test.gravLocked) {
            test.gravityVector = player.gravityVector;
            gravToGlobal(test);
            test.fall=true;
        }
    }
    
    function gravToGlobal(object) {
        object.invertX = 1;
        object.invertY = 1;
        object.invertZ = 1;
        // Figure out axis and sign for gravity vector
        if (object.gravityVector[0] != 0) {
            object.orientAxis = 2;
            object.localX = 1;
            object.localY = 0;
            object.localZ = 2;
            if (object.gravityVector[0] > 0) {
                object.invertY = -1;
                object.orientOffset = -90.0;
                object.gravitySign = 1;
            } else {
                object.invertX = -1;
                object.orientOffset = 90.0;
                object.gravitySign = -1;
            }
        } else if (object.gravityVector[1] != 0) {
            object.orientAxis = 2;
            object.localX = 0;
            object.localY = 1;
            object.localZ = 2;
            if (object.gravityVector[1] > 0) {
                object.invertX = -1;
                object.invertY = -1;
                object.orientOffset = 180.0;
                object.gravitySign = 1;
            } else {
                object.orientOffset = 0.0;
                object.gravitySign = -1;
            }
        } else {
            object.orientAxis = 0;
            object.localX = 0;
            object.localY = 2;
            object.localZ = 1;
            if (object.gravityVector[2] > 0) {
                object.orientOffset = 90.0;
                object.invertY = -1;
                object.gravitySign = 1;
            } else {
                object.invertZ = -1;
                object.orientOffset = -90.0;
                object.gravitySign = -1;
            }
        }
    }
    
    function checkMouse() {  
        // Mouse x-axis
        if (mousePos[0] >= 0) {
            player.rotationVector[player.localY] += player.invertY * Math.pow(Math.abs(mousePos[0]) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        } else {
            player.rotationVector[player.localY] -= player.invertY * Math.pow(Math.abs(mousePos[0]) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        }
                
        if (player.rotationVector[player.localY] < 0) {
            player.rotationVector[player.localY] = 360;
        } else {
            player.rotationVector[player.localY] %= 360;
        }
        
        // Mouse y-axis
        if (mousePos[1] >= 0) {
            player.rotationVector[player.localX] += player.invertX * Math.pow(Math.abs(mousePos[1]) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        } else {
            player.rotationVector[player.localX] -= player.invertX * Math.pow(Math.abs(mousePos[1]) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        }

        if (player.rotationVector[player.localX] >= 90) {
            player.rotationVector[player.localX] = 90;
        } else if (player.rotationVector[player.localX] <= -90) {
            player.rotationVector[player.localX] = -90;
        }
    }
    
    function startRay() {
		var negate;
		var negate2;
		var negate3;
		var xRot;
		var yRot;
		var rayDir;
		if (player.localY == 1) {
			xRot = 1;
			yRot = 0;
			negate = 1;
			negate2 = -1;
			negate3 = -1;
			
			rayDir = [player.globalPosition[0] + (negate * rayLen * Math.sin(degToRad(player.rotationVector[xRot])) * Math.cos(degToRad(player.rotationVector[yRot]))),
						  player.globalPosition[1] + (negate2 * rayLen * Math.sin(degToRad(player.rotationVector[yRot]))),
						  player.globalPosition[2] + (negate3 *  rayLen * Math.cos(degToRad(player.rotationVector[xRot])) * Math.cos(degToRad(player.rotationVector[yRot])))];
		}
		else if (player.localY == 0) {
			xRot = 1;
			yRot = 0;
			negate = 1;
			negate2 = -1;
			negate3 = -1;
			
			rayDir = [player.globalPosition[0] + (negate * rayLen * Math.sin(degToRad(player.rotationVector[xRot])) * Math.cos(degToRad(player.rotationVector[yRot]))),
						  player.globalPosition[1] + (negate2 * rayLen * Math.sin(degToRad(player.rotationVector[yRot]))),
						  player.globalPosition[2] + (negate3 *  rayLen * Math.cos(degToRad(player.rotationVector[xRot])) * Math.cos(degToRad(player.rotationVector[yRot])))];
		}
		else if (player.localY == 2) {
			xRot = 2;
			yRot = 0;
			negate = 1;
			negate2 = 1;
			negate3 = -1;

			rayDir = [player.globalPosition[0] + (negate * rayLen * Math.sin(degToRad(player.rotationVector[xRot])) * Math.cos(degToRad(player.rotationVector[yRot]))),
						   player.globalPosition[1] + (negate3 *  rayLen * Math.cos(degToRad(player.rotationVector[xRot])) * Math.cos(degToRad(player.rotationVector[yRot]))),
						   player.globalPosition[2] + (negate2 * rayLen * Math.sin(degToRad(player.rotationVector[yRot])))];
		}
		
		return rayCheck(rayDir);
	}
	
	function rayCheck (direction) {
		for (var t = 0; t <= 1; t += rayIter) {
			var rx = player.globalPosition[0] + ((direction[0] - player.globalPosition[0]) * t);
			var ry = player.globalPosition[1] + ((direction[1] - player.globalPosition[1]) * t);
			var rz = player.globalPosition[2] + ((direction[2] - player.globalPosition[2]) * t);
			for (var i = 0; i < rayObjects.length; i++) {
				if (rx >= (rayObjects[i].globalPosition[0] - (0.5 * rayObjects[i].dimensions[0])) && rx <= (rayObjects[i].globalPosition[0] + (0.5 * rayObjects[i].dimensions[0]))) {
					if (ry >= (rayObjects[i].globalPosition[1] - (0.5 * rayObjects[i].dimensions[1])) && ry <= (rayObjects[i].globalPosition[1] + (0.5 * rayObjects[i].dimensions[1]))) {
						if (rz >= (rayObjects[i].globalPosition[2] - (0.5 * rayObjects[i].dimensions[2])) && rz <= (rayObjects[i].globalPosition[2] + (0.5 * rayObjects[i].dimensions[2]))) {
							console.log("object: " + i);
							rayObjects[i].rayHit=true;
							rayObjects[i].glowBegin=new Date();
							return rayObjects[i];
						}
					}
				}
			}
		}
		return null;
	}
    
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
        mat4.identity(mvMatrix);
        
		if (showMenu) {
			
			
			gl.useProgram(lightShaderProgram);
			test.draw(lightShaderProgram);
			gl.useProgram(textureShaderProgram);
			mvPushMatrix();
			mat4.translate(mvMatrix, [0.0, 0.0, -7.3]);
			title.draw(textureShaderProgram);
			mvPopMatrix();
			mvPushMatrix();
			mat4.translate(mvMatrix, [-2.0, 1.0, -12.0]);
			playButton.draw(textureShaderProgram);
			mvPopMatrix();
		}
		else {
			if (rayTracing) {
				drawBeam();
			}
			if (rayTracing2) {
				drawBeam2();
			}
			// Draw Cube
			gl.useProgram(lightShaderProgram);
			mvPushMatrix();
			
			var og = [0, 0, 0];
			og[player.orientAxis] = 1;
			mat4.rotate(mvMatrix, degToRad(player.orientOffset), og);
			
			var vg = [0, 0, 0];
			vg[player.localX] = 1;
			mat4.rotate(mvMatrix, degToRad(player.rotationVector[player.localX]), vg);
			
			var hg = [0, 0, 0];
			hg[player.localY] = 1;
			mat4.rotate(mvMatrix, degToRad(player.rotationVector[player.localY]), hg);
			
			mat4.translate(mvMatrix, [-player.globalPosition[0], -player.globalPosition[1], -player.globalPosition[2]]);

			//cube.draw(lightShaderProgram);
			
			if(level==2 && !levelSetUp){
				player.globalPosition[0]=0;
				player.globalPosition[1]=0;
				player.globalPosition[2]=0;
				
				test.globalPosition[0]=0;
				test.globalPosition[1]=0;
				test.globalPosition[2]=0;
				
				test.gravLocked=false;
				
				walls.length=0
				walls = [lvlTop, lvlBot, lvlTop2, lvlTop3, lvlBot2, lvlBot3, lvlRt, lvlRt2, lvlLt2, lvlFrnt, lvlFrnt2, lvlLt, lvlBack2, lvlBack3];
				for(i=0;i<walls.length;i++){
       				walls[i].initObject();
       			}
				console.log("walls"+walls.length);
				rayObjects.length=0;
				rayObjects[rayObjects.length]=test;
				for(j=0;j<walls.length;j++){
					rayObjects[rayObjects.length]=walls[j];
				}
				drawDoor=false;
				levelSetUp=true;
				
				changeGravity();
			}
			for(i=0;i<walls.length;i++){
				if(walls[i].rayHit){
					gl.useProgram(glowTextureShaderProgram);
					walls[i].isLit=false;
					walls[i].draw(glowTextureShaderProgram);
					walls[i].glowCurrent=new Date();
					if(walls[i].glowCurrent-walls[i].glowBegin >500){
						walls[i].rayHit=false;
						walls[i].isLit=true;
						}
				}
				else{
					walls[i].draw(lightShaderProgram);
				}
			}
			/*walls[0].draw(lightShaderProgram);
			lvlBot.draw(lightShaderProgram);
			lvlRt.draw(lightShaderProgram);
			lvlLt.draw(lightShaderProgram);
			lvlFrnt.draw(lightShaderProgram);
			lvlBack.draw(lightShaderProgram);*/
			
			mvPushMatrix();
			if(test.rayHit){
				gl.useProgram(glowTextureShaderProgram);
				mat4.translate(mvMatrix, test.globalPosition);
				test.isLit=false;
				test.draw(glowTextureShaderProgram);
				test.glowCurrent=new Date();
				console.log(test.glowCurrent+","+test.glowBegin);
				if(test.glowCurrent - test.glowBegin > 500){
					console.log(test.glowCurrent-test.glowBegin);
					test.rayHit=false;
					test.isLit=true;
				}
			}
			else{
			mat4.translate(mvMatrix, test.globalPosition);
			test.draw(lightShaderProgram);
			}
			gl.useProgram(lightShaderProgram);
			mvPopMatrix();
			if(level==1) {
				mvPushMatrix();
				mat4.translate(mvMatrix, sensor.globalPosition);
				sensor.draw(lightShaderProgram);
			
				mvPopMatrix();
			}
			mvPushMatrix();
			mat4.translate(mvMatrix, sensor2.globalPosition);
       	 	sensor2.draw(lightShaderProgram);
        
			mvPopMatrix();
			if(drawDoor){
				mvPushMatrix();
				mat4.translate(mvMatrix, door.globalPosition);
       			door.draw(lightShaderProgram);
        		mvPopMatrix();
        	}
			mvPopMatrix();
			
			// Draw Crosshair
			mvPushMatrix();
			gl.useProgram(textureShaderProgram);
			mat4.translate(mvMatrix, [0.0, 0.0, -50.0]);
		
			crosshair.draw(textureShaderProgram);
			mvPopMatrix();
		}
    }

    function update() {
        if(firstTimeThrough){
            oldTime = new Date();
            currentTime = new Date();
            firstTimeThrough = false;
        }
        
        oldTime = currentTime;
        currentTime = new Date();
        timeDelta = currentTime - oldTime;
        fps = 1000 / timeDelta;

		checkMouse();
        
		if(!showMenu) {
			checkKeys();
            updatePositions(moveables, timeDelta);
            
            //var minObj = startRay();
        }
    }
    
    function fall(objs, timeDelta) {
        for (var i = 0; i < objs.length; i++) {
            if (objs[i].fall) { 
                objs[i].velocity[objs[i].localY] += objs[i].invertY * MOVEMENT_SPEED;
            }
        }
    }
    
    function updatePositions(objs, timeDelta) {
        // Update falling objects' velocities
        fall(moveables, timeDelta);
        
        for (var i = 0; i < objs.length; i++) {
            var obj = objs[i];
            var X = obj.localX;
            var Y = obj.localY;
            var Z = obj.localZ;
            
            var collision = checkCollision(obj, walls, timeDelta);
        	sensorArray=[sensor,sensor2];
        	if(checkCollision(test,sensorArray,timeDelta)){
        		drawDoor=true;
        			doorArray=[door];
        			if(checkCollision(player,doorArray,timeDelta)){
        					debug("LEVEL COMPLETE");
        					level=2;
        					drawDoor=false;
        					//drawScene();
        				}
        		}
        	else{
        		drawDoor=false;
        		}
            if (!collision) {
                obj.globalPosition[X] -= timeDelta / 70 * obj.velocity[X];
                obj.globalPosition[Y] += timeDelta / 1000 * obj.velocity[Y];
                obj.globalPosition[Z] += timeDelta / 70 * obj.velocity[Z];
            } else {
                console.log("Collision");
                obj.fall = false;
                obj.velocity[X] = 0;
                obj.velocity[Y] = 0;
                obj.velocity[Z] = 0;
            }
        }
    }
    
    function checkCollision(obj, objArray, timeDelta) {
        var collisions = [false, false, false];
        //var distance = [0, 0, 0];
        //var minDistance = [0, 0, 0];
        
        var X = obj.localX; var Y = obj.localY; var Z = obj.localZ;
        var x1 = obj.globalPosition[X] - timeDelta / 70 * obj.velocity[X];
        var y1 = obj.globalPosition[Y] + timeDelta / 1000 * obj.velocity[Y];
        var z1 = obj.globalPosition[Z] + timeDelta / 70 * obj.velocity[Z];
        
        for (var i = 0; i < objArray.length; i++) {
            var obj2 = objArray[i];
            
            var x2 = obj2.globalPosition[X];
            var y2 = obj2.globalPosition[Y];
            var z2 = obj2.globalPosition[Z];
            
            if (Math.abs(x1 - x2) < (obj.dimensions[X] + obj2.dimensions[X]) / 2 + COLLISION_DISTANCE) {
                if (Math.abs(y1 - y2) < (obj.dimensions[Y] + obj2.dimensions[Y]) / 2 + COLLISION_DISTANCE) {
                    if (Math.abs(z1 - z2) < (obj.dimensions[Z] + obj2.dimensions[Z]) / 2 + COLLISION_DISTANCE) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    function handleKeyDown(evt) {
        keyDown[evt.keyCode] = true;        
    }
 
    function handleKeyUp(evt) {
        keyDown[evt.keyCode] = false;
    }
    
    function handleMouseMove(evt) {
        if (navigator.userAgent.indexOf("Firefox")!=-1) {
            mousePos[0] = evt.clientX - canvas.offsetLeft - canvas.width / 2;
            mousePos[1] = evt.clientY - canvas.offsetTop - canvas.height / 2;
        } else {
            mousePos[0] = evt.x - canvas.offsetLeft - canvas.width / 2;
            mousePos[1] = evt.y - canvas.offsetTop - canvas.height / 2;
        }
	}
	
	function handleMouseDown(evt) {
		if (!showMenu) {
			if (!spacePressed) {
				rayTracing = true;
				var minObj = startRay();
				if (minObj != null) {
					if (minObj.pos != null) {
						if (minObj.pos == "right") { // Left
							player.gravityVector = [-1, 0, 0];
							changeGravity();
						} else if (minObj.pos == "up") { // Up
							player.gravityVector = [0, 1, 0];
							changeGravity();
						} else if (minObj.pos == "left") { // Right
							player.gravityVector = [1, 0, 0];
							changeGravity();
						} else if (minObj.pos == "down") { // Down
							player.gravityVector = [0, -1, 0];
							changeGravity();
						} else if (minObj.pos == "back") { // F (Front)
							player.gravityVector = [0, 0, -1];
							changeGravity();
						} else if (minObj.pos == "front") { // B (Back)
							player.gravityVector = [0, 0, 1];
							changeGravity();
						}
					}
				}
			}
			else {
				rayTracing2 = true;
				var minObj = startRay();
				if (minObj != null) {
					if (minObj.gravLocked != null) {
						minObj.gravLocked = !minObj.gravLocked;
					}
				}
			
			}
		}
	}
	
	function handleMouseUp(evt) {
		rayTracing = false;
		rayTracing2 = false;
	}
    
    function handleMouseClick(evt) {
        if (showMenu) {
			var playButtonX = -240;
			var playButtonY = -120;
			var playButtonWidth = 240;
			var playButtonHeight = 120;
			if (mousePos[0] >= playButtonX && mousePos[0] <= playButtonX + playButtonWidth) {
				if (mousePos[1] >= playButtonY && mousePos[1] <= playButtonY + playButtonHeight) {
					showMenu = false;
				}
			}
		}
	}
    
    function debug(text) {
        document.getElementById('debug').innerHTML = text;
    }
    
</script>
</head>

<body onload="init()" style="text-align:center">
    <canvas id="Canvas" width="800" height="600" style="border:1px solid #eeeeee ">
        Your browser does not support the canvas element.
    </canvas>
    <div id="debug"></div>
</body>
</html>
