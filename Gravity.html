<!DOCTYPE HTML>
<html>
<head>
<title>Gravity</title>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
        precision highp float;
    #endif

    varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vColor;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
    }
</script>

<script id="texture-shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
        precision highp float;
    #endif

    varying vec2 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 color = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4 (color.r * color.a, color.g * color.a, color.b * color.a, color.a);
    }
</script>

<script id="texture-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
	}
	</script>
	
<script id="light-shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
        precision highp float;
    #endif

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
	varying vec4 vPosition;
	
	uniform mat4 uMVMatrix;	
    
	uniform vec3 uAmbientColor;
    
    uniform float uMaterialShininess;
    
    uniform vec3 uLightingLocation;
	uniform vec3 uLightingSpecularColor;
    uniform vec3 uLightingDiffuseColor;

    uniform sampler2D uSampler;

    void main(void) {
		vec3 transformedDir = vec3(uMVMatrix * vec4(uLightingLocation, 0.0));
        vec3 lightDirection = normalize(transformedDir - vPosition.xyz);
        vec3 normal = normalize(vTransformedNormal);
      
        vec3 eyeDirection = normalize(-vPosition.xyz);
        vec3 reflectionDirection = reflect(-lightDirection, normal);

        float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);

        float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
        vec3 lightWeighting = uAmbientColor + uLightingDiffuseColor * diffuseLightWeighting;

        vec4 fragmentColor;
        fragmentColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4((fragmentColor.rgb * lightWeighting) + uLightingSpecularColor * specularLightWeighting , fragmentColor.a);
    }
</script>

<script id="light-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

	varying vec2 vTextureCoord;
	varying vec3 vTransformedNormal;
	varying vec4 vPosition;

    void main(void) {
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		vTextureCoord = aTextureCoord;
		vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>

<script type="text/javascript" src="jquery-1.6.4.js"></script>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

<script type="text/javascript" src="objects/DrawableObject.js"></script>

<script type="text/javascript" src="objects/HUDObject.js"></script>

<script type="text/javascript" src="objects/GameObject.js"></script>

<script type="text/javascript" src="objects/BeamObject.js"></script>

<script type="text/javascript" src="objects/LevelObject.js"></script>


<script type="text/javascript">
    
    var MOUSE_SENSITIVITY = 0.7; // Higher = more sensitive
    var MOUSE_EXPONENT = 1.4; // Higher = quicker ramp up
    var MOVEMENT_SPEED = -0.07;
    var COLLISION_DISTANCE = .2;
    
    var canvas;
    
//OPEN GL VARS
    var gl;
    var shaderProgram;
    var lightShaderProgram;
    var textureShaderProgram;
    
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();
        
    var INTERVAL = 60;
    var timeDelta;
    var currentTime;
    var oldTime;
    var fps;
    var firstTimeThrough;
        
    var keyDown = new Array();
    var mousePos = vec3.create();
    
    var player;

    var cube;
    var crosshair;
	var test;
	
    var ambientLight = [0.2, 0.2, 0.2];
	var lightPos = [1.0, 3.0, 0.0];
	var lightDiffColor = [0.7, 0.7, 0.7];
	var lightSpecColor = [0.4, 0.4, 0.4];
    
    var rayLen = 5;
	var rayIter = 0.001;

	var rayTracing = false;
	var showMenu = true;
  
    function init() {
        canvas = document.getElementById("Canvas");
    
        document.onkeyup = handleKeyUp;
        document.onkeydown = handleKeyDown;
        document.onmousedown = handleMouseDown;
		document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;
		document.onclick = handleMouseClick;
                
        webGLStart(canvas);
        
        firstTimeThrough = true;

        setInterval(function() {
                    update();
                    drawScene();
                    }, 1000 / INTERVAL);
    }
    
    function webGLStart(canvas) {
        initGL(canvas);
        createObjects();
        initShaders();
        initBuffers();
		setBallList(20);
        
        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.enable(gl.TEXTURE_2D);
        
        //// Disable CullFace for now so that cube renders on both sides
        gl.disable(gl.CULL_FACE);
        ////
        
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    }

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
            alert("Could not initialise WebGL");
        }
        if (!gl) {
            alert("Could not initialise WebGL");
        }
    }
    
    function createObjects() {
        player = new GameObject([0.0, 0.0, 0.0], 60.0, [0, -1, 0], [0.0, 0.0, 0.0], false, null);
        
        player.dimensions[0] = .1;
        player.dimensions[1] = .1;
        player.dimensions[2] = .1;
        
        //cube = new GameObject([0.0, 0.0, 0.0], 60.0, [0, -1, 0], [0.0, 0.0, 0.0], true, false, "textures/checker1-pCube1.1.jpg");
        //cube.loadModel("models/Level1.obj");
        lvlTop = new LevelObject(true,false,"textures/CubeTop.png");
        lvlTop.loadModel("models/lvlTop.obj");
        
        lvlBot = new LevelObject(true,false,"textures/CubeBot.png");
        lvlBot.loadModel("models/lvlBot.obj");
        
        lvlLt = new LevelObject(true,false,"textures/CubeLt.png");
        lvlLt.loadModel("models/lvlLft.obj");
        
        lvlRt = new LevelObject(true,false,"textures/CubeRt.png");
        lvlRt.loadModel("models/lvlRt.obj");
        
        lvlFrnt = new LevelObject(true,false,"textures/CubeFrt.png");
        lvlFrnt.loadModel("models/lvlFrnt.obj");
        
        lvlBack = new LevelObject(true,false,"textures/CubeBack.png");
        lvlBack.loadModel("models/lvlBack.obj");
        
        crosshair = new HUDObject("textures/Crosshair.png");
		title = new HUDObject("images/title.png");
		playButton = new HUDObject("images/menu_play.png");
		
        test = new GameObject([0.0, 0.0, 0.0], 60.0, [0, -1, 0], [0.0, 0.0, 0.0], true, "textures/ramp1-pCube1.jpg");
		test.loadModel("models/cube.obj");
		
		beam = new GameObject([0.0, 0.0, 0.0], 60.0, [0.0, -1.0, 0.0], [0.0, 0.0, 0.0], true, "textures/beam.png");
		beam.loadModel("models/beam.obj");
        
        changeGravity();
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
			console.log("Shader not found");
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function initShaders() {
        // Cube color shaders
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");
        
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
                
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        
        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
        
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        
        // Texture Shaders
        var textureFragmentShader = getShader(gl, "texture-shader-fs");
        var textureVertexShader = getShader(gl, "texture-shader-vs");
        
        textureShaderProgram = gl.createProgram();
        gl.attachShader(textureShaderProgram, textureVertexShader);
        gl.attachShader(textureShaderProgram, textureFragmentShader);
        gl.linkProgram(textureShaderProgram);
        
        if (!gl.getProgramParameter(textureShaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        
        textureShaderProgram.vertexPositionAttribute = gl.getAttribLocation(textureShaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(textureShaderProgram.vertexPositionAttribute);
        
        textureShaderProgram.textureCoordAttribute = gl.getAttribLocation(textureShaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(textureShaderProgram.textureCoordAttribute);
        
        textureShaderProgram.pMatrixUniform = gl.getUniformLocation(textureShaderProgram, "uPMatrix");
        textureShaderProgram.mvMatrixUniform = gl.getUniformLocation(textureShaderProgram, "uMVMatrix");
        textureShaderProgram.samplerUniform = gl.getUniformLocation(textureShaderProgram, "uSampler");
		
        // Light Shaders
        var lightFragmentShader = getShader(gl, "light-shader-fs");
        var lightVertexShader = getShader(gl, "light-shader-vs");
        
        lightShaderProgram = gl.createProgram();
        gl.attachShader(lightShaderProgram, lightVertexShader);
        gl.attachShader(lightShaderProgram, lightFragmentShader);
        gl.linkProgram(lightShaderProgram);
        
        if (!gl.getProgramParameter(lightShaderProgram, gl.LINK_STATUS)) {
            console.log("Could not initialise shaders");
        }
        
		lightShaderProgram.vertexPositionAttribute = gl.getAttribLocation(lightShaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(lightShaderProgram.vertexPositionAttribute);

        lightShaderProgram.vertexNormalAttribute = gl.getAttribLocation(lightShaderProgram, "aVertexNormal");
		gl.enableVertexAttribArray(lightShaderProgram.vertexNormalAttribute);

        lightShaderProgram.textureCoordAttribute = gl.getAttribLocation(lightShaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(lightShaderProgram.textureCoordAttribute);
		
        lightShaderProgram.pMatrixUniform = gl.getUniformLocation(lightShaderProgram, "uPMatrix");
        lightShaderProgram.mvMatrixUniform = gl.getUniformLocation(lightShaderProgram, "uMVMatrix");
		lightShaderProgram.nMatrixUniform = gl.getUniformLocation(lightShaderProgram, "uNMatrix");
        lightShaderProgram.samplerUniform = gl.getUniformLocation(lightShaderProgram, "uSampler");
		lightShaderProgram.materialShininessUniform = gl.getUniformLocation(lightShaderProgram, "uMaterialShininess");
		lightShaderProgram.ambientColorUniform = gl.getUniformLocation(lightShaderProgram, "uAmbientColor");
        lightShaderProgram.lightingLocationUniform = gl.getUniformLocation(lightShaderProgram, "uLightingLocation");
        lightShaderProgram.lightingDiffuseColorUniform = gl.getUniformLocation(lightShaderProgram, "uLightingDiffuseColor");
		lightShaderProgram.lightingSpecularColorUniform = gl.getUniformLocation(lightShaderProgram, "uLightingSpecularColor");
    }

    function initBuffers() {
    // Crosshair Buffers
        crosshair.vertices = [-1.0, -1.0,  0.0,
                              1.0, -1.0,  0.0,
                              1.0,  1.0,  0.0,
                             -1.0,  1.0,  0.0];
                             
        crosshair.textCoords = [0.0, 0.0,
                                1.0, 0.0,
                                1.0, 1.0,
                                0.0, 1.0];
                                
        crosshair.indices = [0, 1, 2, 0, 2, 3];
        
        crosshair.initObject();
		
		title.vertices = [-4.0, -3.0,  0.0,
                          4.0, -3.0,  0.0,
                          4.0,  3.0,  0.0,
                         -4.0,  3.0,  0.0];
                             
        title.textCoords = [0.0, 0.0,
                            1.0, 0.0,
                            1.0, 1.0,
                            0.0, 1.0];
                                
        title.indices = [0, 1, 2, 0, 2, 3];
        
        title.initObject();
		
		playButton.vertices = [-2.0, -1.0,  0.0,
				  2.0, -1.0,  0.0,
				  2.0,  1.0,  0.0,
				 -2.0,  1.0,  0.0];
                             
        playButton.textCoords = [0.0, 0.0,
                            1.0, 0.0,
                            1.0, 1.0,
                            0.0, 1.0];
                                
        playButton.indices = [0, 1, 2, 0, 2, 3];
        
        playButton.initObject();
        
       // cube.initObject();
       	lvlTop.initObject();
       	lvlBot.initObject();
       	lvlRt.initObject();
       	lvlLt.initObject();
       	lvlFrnt.initObject();
       	lvlBack.initObject();
		
		test.initObject();
		beam.initObject();
    }
    
    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms(program) {
        gl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);
		
		var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(program.nMatrixUniform, false, normalMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }
           
    function checkKeys() {
        if (keyDown[87]) { // W
            player.localOffset[2] += MOVEMENT_SPEED;
        }
        
        if (keyDown[83]) { // S
            player.localOffset[2] -= MOVEMENT_SPEED;
        }
        
        if (keyDown[65]) { // A
            player.localOffset[0] += MOVEMENT_SPEED;
        }
        
        if (keyDown[68]) { // D
            player.localOffset[0] -= MOVEMENT_SPEED;
        }
        
        if (keyDown[37]) { // Left
            player.gravityVector = [-1, 0, 0];
            changeGravity();
        }
        
        if (keyDown[38]) { // Up
            player.gravityVector = [0, 1, 0];
            changeGravity();
        }
        
        if (keyDown[39]) { // Right
            player.gravityVector = [1, 0, 0];
            changeGravity();
        }
        
        if (keyDown[40]) { // Down
            player.gravityVector = [0, -1, 0];
            changeGravity();
        }
        
        if (keyDown[70]) { // F (Front)
            player.gravityVector = [0, 0, -1];
            changeGravity();
        }
        
        if (keyDown[66]) { // B (Back)
            player.gravityVector = [0, 0, 1];
            changeGravity();
        }
        
        var angle = player.invertY * player.rotationVector[player.localY];
        
        player.globalPosition[player.localX] -= player.invertX * player.localOffset[2] * Math.sin(degToRad(angle));
        player.globalPosition[player.localZ] += player.invertZ * player.localOffset[2] * Math.cos(degToRad(angle));
        
        player.globalPosition[player.localX] -= player.invertX * player.localOffset[0] * Math.sin(degToRad(-90.0 + angle));
        player.globalPosition[player.localZ] += player.invertZ * player.localOffset[0] * Math.cos(degToRad(-90.0 + angle));
        
        
        //debug("Angle " + angle + " Position " + player.globalPosition[0] + " " + player.globalPosition[1] + " " + player.globalPosition[2]);
        
        player.localOffset[0] = 0.0;
        player.localOffset[1] = 0.0;
        player.localOffset[2] = 0.0;
    }
    
	function rayVec() {
		this.gravityVector = [0,-1,0];
	}
	var rayVector = new rayVec();
    function changeGravity() {
        gravToGlobal(player);
		gravToGlobal(rayVector);
        player.fall = true;
        if (!test.gravLocked) {
            test.gravityVector = player.gravityVector;
            gravToGlobal(test);
        }
    }
    
    function gravToGlobal(object) {
        object.invertX = 1;
        object.invertY = 1;
        object.invertZ = 1;
        // Figure out axis and sign for gravity vector
        if (object.gravityVector[0] != 0) {
            object.orientAxis = 2;
            object.localX = 1;
            object.localY = 0;
            object.localZ = 2;
            if (object.gravityVector[0] > 0) {
                object.invertY = -1;
                object.orientOffset = -90.0;
                object.gravitySign = 1;
            } else {
                object.invertX = -1;
                object.orientOffset = 90.0;
                object.gravitySign = -1;
            }
        } else if (object.gravityVector[1] != 0) {
            object.orientAxis = 2;
            object.localX = 0;
            object.localY = 1;
            object.localZ = 2;
            if (object.gravityVector[1] > 0) {
                object.invertX = -1;
                object.invertY = -1;
                object.orientOffset = 180.0;
                object.gravitySign = 1;
            } else {
                object.orientOffset = 0.0;
                object.gravitySign = -1;
            }
        } else {
            object.orientAxis = 0;
            object.localX = 0;
            object.localY = 2;
            object.localZ = 1;
            if (object.gravityVector[2] > 0) {
                object.orientOffset = 90.0;
                object.invertY = -1;
                object.gravitySign = 1;
            } else {
                object.invertZ = -1;
                object.orientOffset = -90.0;
                object.gravitySign = -1;
            }
        }
    }
    
    function checkMouse() {  
        // Mouse x-axis
        if (mousePos[0] >= 0) {
            player.rotationVector[player.localY] += player.invertY * Math.pow(Math.abs(mousePos[0]) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        } else {
            player.rotationVector[player.localY] -= player.invertY * Math.pow(Math.abs(mousePos[0]) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        }
                
        if (player.rotationVector[player.localY] < 0) {
            player.rotationVector[player.localY] = 360;
        } else {
            player.rotationVector[player.localY] %= 360;
        }
        
        // Mouse y-axis
        if (mousePos[1] >= 0) {
            player.rotationVector[player.localX] += player.invertX * Math.pow(Math.abs(mousePos[1]) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        } else {
            player.rotationVector[player.localX] -= player.invertX * Math.pow(Math.abs(mousePos[1]) / 100 * MOUSE_SENSITIVITY, MOUSE_EXPONENT);
        }

        if (player.rotationVector[player.localX] >= 90) {
            player.rotationVector[player.localX] = 90;
        } else if (player.rotationVector[player.localX] <= -90) {
            player.rotationVector[player.localX] = -90;
        }
    }
    
    function startRay() {
		var xRot = rayVector.localY;
		var yRot = rayVector.localX;
		var rayDir = [player.globalPosition[0] + rayLen * Math.sin(degToRad(player.rotationVector[xRot])) * Math.cos(degToRad(player.rotationVector[yRot])),
                      player.globalPosition[1] -  rayLen * Math.sin(degToRad(player.rotationVector[yRot])),
                      player.globalPosition[2] - rayLen * Math.cos(degToRad(player.rotationVector[xRot])) * Math.cos(degToRad(player.rotationVector[yRot]))];
		return rayCheck(rayDir);
	}
	
	function rayCheck (direction) {
		for (var t = 0; t <= 1; t += rayIter) {
			var rx = player.globalPosition[0] + ((direction[0] - player.globalPosition[0]) * t);
			var ry = player.globalPosition[1] + ((direction[1] - player.globalPosition[1]) * t);
			var rz = player.globalPosition[2] + ((direction[2] - player.globalPosition[2]) * t);
			if (rx >= (test.globalPosition[0] - (0.5 * test.dimensions[0])) && rx <= (test.globalPosition[0] + (0.5 * test.dimensions[0]))) {
				if (ry >= (test.globalPosition[1] - (0.5 * test.dimensions[1])) && ry <= (test.globalPosition[1] + (0.5 * test.dimensions[1]))) {
					if (rz >= (test.globalPosition[2] - (0.5 * test.dimensions[2])) && rz <= (test.globalPosition[2] + (0.5 * test.dimensions[2]))) {
						console.log("test");
						return test;
					}
				}
			}
		}
		return null;
	}
    
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
        mat4.identity(mvMatrix);
        
		if (showMenu) {
			
			
			gl.useProgram(lightShaderProgram);
			test.draw(lightShaderProgram);
			gl.useProgram(textureShaderProgram);
			mvPushMatrix();
			mat4.translate(mvMatrix, [0.0, 0.0, -7.3]);
			title.draw(textureShaderProgram);
			mvPopMatrix();
			mvPushMatrix();
			mat4.translate(mvMatrix, [-2.0, 1.0, -12.0]);
			playButton.draw(textureShaderProgram);
			mvPopMatrix();
		}
		else {
			if (rayTracing) {
				drawBeam();
			}
			
			// Draw Cube
			gl.useProgram(lightShaderProgram);
			mvPushMatrix();
			
			var og = [0, 0, 0];
			og[player.orientAxis] = 1;
			mat4.rotate(mvMatrix, degToRad(player.orientOffset), og);
			
			var vg = [0, 0, 0];
			vg[player.localX] = 1;
			mat4.rotate(mvMatrix, degToRad(player.rotationVector[player.localX]), vg);
			
			var hg = [0, 0, 0];
			hg[player.localY] = 1;
			mat4.rotate(mvMatrix, degToRad(player.rotationVector[player.localY]), hg);
			
			mat4.translate(mvMatrix, [-player.globalPosition[0], -player.globalPosition[1], -player.globalPosition[2]]);

			//cube.draw(lightShaderProgram);
			lvlTop.draw(lightShaderProgram);
			lvlBot.draw(lightShaderProgram);
			lvlRt.draw(lightShaderProgram);
			lvlLt.draw(lightShaderProgram);
			lvlFrnt.draw(lightShaderProgram);
			lvlBack.draw(lightShaderProgram);
			
			mvPushMatrix();
			mat4.translate(mvMatrix, test.globalPosition);
			test.draw(lightShaderProgram);
			
			mvPopMatrix();
			mvPopMatrix();
			
			// Draw Crosshair
			mvPushMatrix();
			gl.useProgram(textureShaderProgram);
			mat4.translate(mvMatrix, [0.0, 0.0, -50.0]);
		
			crosshair.draw(textureShaderProgram);
			mvPopMatrix();
		}
    }

    function update() {
        if(firstTimeThrough){
            oldTime = new Date();
            currentTime = new Date();
            firstTimeThrough = false;
        }
        oldTime = currentTime;
        currentTime = new Date();
        timeDelta = currentTime - oldTime;
        fps = 1000 / timeDelta;

		checkMouse();
		if(!showMenu) {
			if (test.fall) {
				objAnimate(test, timeDelta);
			}
			
			if (player.fall) {
				objAnimate(player, timeDelta);
			}
					
			checkKeys();
            var minObj = startRay();
            if (minObj != null) {
                console.log("hit");
            }
        }
    }
    
    function objAnimate(obj, timeDelta) {    
        var walls = [lvlTop, lvlBot, lvlRt, lvlLt, lvlBack, lvlFrnt];
        var dist = checkCollision(obj, walls);

        if (dist[obj.localY] > Math.abs(obj.gravitySign * 9.8 * timeDelta / 5000.0)) {
            obj.globalPosition[obj.localY] += obj.gravitySign * 9.8 * timeDelta / 5000.0;
        } else {
            obj.globalPosition[obj.localY] += obj.gravitySign * (dist[obj.localY] - COLLISION_DISTANCE);
            obj.fall = false;
        }
    }
    
    function checkCollision(obj1, objArray) {
        var distance = [0, 0, 0];
        var minDistance = [0, 0, 0];
        for (var i = 0; i < objArray.length; i++) {
            distance[obj1.localX] = Math.abs(obj1.globalPosition[obj1.localX] - objArray[i].globalPosition[obj1.localX] - (obj1.dimensions[obj1.localX] + objArray[i].dimensions[obj1.localX]) / 2);
            distance[obj1.localY] = Math.abs(obj1.globalPosition[obj1.localY] - objArray[i].globalPosition[obj1.localY] - (obj1.dimensions[obj1.localY] + objArray[i].dimensions[obj1.localY]) / 2);
            distance[obj1.localZ] = Math.abs(obj1.globalPosition[obj1.localZ] - objArray[i].globalPosition[obj1.localZ] - (obj1.dimensions[obj1.localZ] + objArray[i].dimensions[obj1.localZ]) / 2);
            
            if (i == 0) {
                minDistance[obj1.localX] = distance[obj1.localX];
                minDistance[obj1.localY] = distance[obj1.localY];
                minDistance[obj1.localZ] = distance[obj1.localZ];
            } else {
                if (distance[obj1.localX] < minDistance[obj1.localX]) { minDistance[obj1.localX] = distance[obj1.localX]; }
                if (distance[obj1.localY] < minDistance[obj1.localY]) { minDistance[obj1.localY] = distance[obj1.localY]; }
                if (distance[obj1.localZ] < minDistance[obj1.localZ]) { minDistance[obj1.localZ] = distance[obj1.localZ]; }
            }
        }
        return minDistance;
    }
    
    function handleKeyDown(evt) {
        keyDown[evt.keyCode] = true;        
    }
 
    function handleKeyUp(evt) {
        keyDown[evt.keyCode] = false;
    }
    
    function handleMouseMove(evt) {
        if (navigator.userAgent.indexOf("Firefox")!=-1) {
            mousePos[0] = evt.clientX - canvas.offsetLeft - canvas.width / 2;
            mousePos[1] = evt.clientY - canvas.offsetTop - canvas.height / 2;
        } else {
            mousePos[0] = evt.x - canvas.offsetLeft - canvas.width / 2;
            mousePos[1] = evt.y - canvas.offsetTop - canvas.height / 2;
        }
	}
	
	function handleMouseDown(evt) {
		if (!showMenu) {
			rayTracing = true;
			var minObj = startRay();
			if (minObj != null) {
				//Do stuff
			}
			if (test.fall == false) {
				test.fall = true;
			} else {
				test.fall = false;
			}
		}
	}
	
	function handleMouseUp(evt) {
		rayTracing = false;
	}
    
    function handleMouseClick(evt) {
        if (showMenu) {
			var playButtonX = -240;
			var playButtonY = -120;
			var playButtonWidth = 240;
			var playButtonHeight = 120;
			if (mousePos[0] >= playButtonX && mousePos[0] <= playButtonX + playButtonWidth) {
				if (mousePos[1] >= playButtonY && mousePos[1] <= playButtonY + playButtonHeight) {
					showMenu = false;
				}
			}
		}
	}
    
    function debug(text) {
        document.getElementById('debug').innerHTML = text;
    }
    
</script>
</head>

<body onload="init()" style="text-align:center">
    <canvas id="Canvas" width="800" height="600" style="border:1px solid #eeeeee ">
        Your browser does not support the canvas element.
    </canvas>
    <div id="debug"></div>
</body>
</html>
